$date
	Fri Jun 07 19:18:45 2024
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module iv_fp_mul_tb $end
$var wire 16 ! out [15:0] $end
$var wire 2 " error [1:0] $end
$var parameter 32 # DATA_WIDTH $end
$var parameter 32 $ ERROR_WIDTH $end
$var reg 16 % in1 [15:0] $end
$var reg 16 & in2 [15:0] $end
$var integer 32 ' i [31:0] $end
$scope module uut $end
$var wire 1 ( NaN_input $end
$var wire 16 ) in1 [15:0] $end
$var wire 16 * in2 [15:0] $end
$var wire 1 + inf_x_0 $end
$var wire 1 , out_is_NaN $end
$var wire 1 - out_is_inf $end
$var wire 1 . out_is_zero $end
$var wire 1 / overflow $end
$var wire 1 0 underflow $end
$var wire 16 1 out [15:0] $end
$var wire 1 2 op3_sign $end
$var wire 7 3 op3_frac [6:0] $end
$var wire 8 4 op3_exp [7:0] $end
$var wire 1 5 op2_sign $end
$var wire 7 6 op2_frac [6:0] $end
$var wire 8 7 op2_exp [7:0] $end
$var wire 1 8 op1_sign $end
$var wire 7 9 op1_frac [6:0] $end
$var wire 8 : op1_exp [7:0] $end
$var wire 1 ; normalise $end
$var wire 1 < in2_is_zero $end
$var wire 1 = in2_is_inf $end
$var wire 1 > in2_is_NaN $end
$var wire 1 ? in1_is_zero $end
$var wire 1 @ in1_is_inf $end
$var wire 1 A in1_is_NaN $end
$var wire 7 B frac_prod_norm [6:0] $end
$var wire 16 C frac_prod [15:0] $end
$var wire 9 D exp_sum_plus_1 [8:0] $end
$var wire 8 E exp_sum_norm [7:0] $end
$var wire 9 F exp_sum_exp1_plus_exp2 [8:0] $end
$var wire 9 G exp_sum [8:0] $end
$var wire 2 H error [1:0] $end
$var parameter 32 I DATA_WIDTH $end
$var parameter 32 J ERROR_WIDTH $end
$var parameter 32 K EXP_WIDTH $end
$var parameter 32 L FRAC_WIDTH $end
$scope module is_NaN_1 $end
$var wire 1 A is_NaN_out $end
$var wire 16 M num [15:0] $end
$var wire 7 N frac [6:0] $end
$var wire 8 O exp [7:0] $end
$var parameter 32 P DATA_WIDTH $end
$var parameter 32 Q EXP_WIDTH $end
$var parameter 32 R FRAC_WIDTH $end
$upscope $end
$scope module is_NaN_2 $end
$var wire 1 > is_NaN_out $end
$var wire 16 S num [15:0] $end
$var wire 7 T frac [6:0] $end
$var wire 8 U exp [7:0] $end
$var parameter 32 V DATA_WIDTH $end
$var parameter 32 W EXP_WIDTH $end
$var parameter 32 X FRAC_WIDTH $end
$upscope $end
$scope module is_inf_1 $end
$var wire 1 @ is_inf_out $end
$var wire 16 Y num [15:0] $end
$var wire 7 Z frac [6:0] $end
$var wire 8 [ exp [7:0] $end
$var parameter 32 \ DATA_WIDTH $end
$var parameter 32 ] EXP_WIDTH $end
$var parameter 32 ^ FRAC_WIDTH $end
$upscope $end
$scope module is_inf_2 $end
$var wire 1 = is_inf_out $end
$var wire 16 _ num [15:0] $end
$var wire 7 ` frac [6:0] $end
$var wire 8 a exp [7:0] $end
$var parameter 32 b DATA_WIDTH $end
$var parameter 32 c EXP_WIDTH $end
$var parameter 32 d FRAC_WIDTH $end
$upscope $end
$scope module is_zero_1 $end
$var wire 1 ? is_zero_out $end
$var wire 16 e num [15:0] $end
$var wire 7 f frac [6:0] $end
$var wire 8 g exp [7:0] $end
$var parameter 32 h DATA_WIDTH $end
$var parameter 32 i EXP_WIDTH $end
$var parameter 32 j FRAC_WIDTH $end
$upscope $end
$scope module is_zero_2 $end
$var wire 1 < is_zero_out $end
$var wire 16 k num [15:0] $end
$var wire 7 l frac [6:0] $end
$var wire 8 m exp [7:0] $end
$var parameter 32 n DATA_WIDTH $end
$var parameter 32 o EXP_WIDTH $end
$var parameter 32 p FRAC_WIDTH $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b111 p
b1000 o
b10000 n
b111 j
b1000 i
b10000 h
b111 d
b1000 c
b10000 b
b111 ^
b1000 ]
b10000 \
b111 X
b1000 W
b10000 V
b111 R
b1000 Q
b10000 P
b111 L
b1000 K
b10 J
b10000 I
b10 $
b10000 #
$end
#0
$dumpvars
b11111111 m
b0 l
b111111110000000 k
b11111111 g
b1000000 f
b111111111000000 e
b11111111 a
b0 `
b111111110000000 _
b11111111 [
b1000000 Z
b111111111000000 Y
b11111111 U
b0 T
b111111110000000 S
b11111111 O
b1000000 N
b111111111000000 M
b11 H
b101111111 G
b111111110 F
b1111111 E
b110000000 D
b110000000000000 C
b1000000 B
1A
0@
0?
0>
1=
0<
0;
b11111111 :
b1000000 9
08
b11111111 7
b0 6
05
b11111111 4
b1000000 3
02
b111111111000000 1
00
1/
0.
1-
1,
0+
b111111110000000 *
b111111111000000 )
1(
b0 '
b111111110000000 &
b111111111000000 %
b11 "
b111111111000000 !
$end
#100
15
b1111111110000000 &
b1111111110000000 *
b1111111110000000 S
b1111111110000000 _
b1111111110000000 k
b1 '
#200
12
b11111111 4
b11 "
b11 H
b1111111111000000 !
b1111111111000000 1
b1000000 3
1+
0-
1,
b10000000 E
0/
1<
b0 B
0(
1@
0=
0A
05
b10000001 D
b10000000 G
b11111111 F
b0 7
b0 U
b0 a
b0 m
b100000000000000 C
b0 9
b0 N
b0 Z
b0 f
b0 &
b0 *
b0 S
b0 _
b0 k
b111111110000000 %
b111111110000000 )
b111111110000000 M
b111111110000000 Y
b111111110000000 e
b10 '
#300
15
b1000000000000000 &
b1000000000000000 *
b1000000000000000 S
b1000000000000000 _
b1000000000000000 k
b11 '
#400
05
18
b0 &
b0 *
b0 S
b0 _
b0 k
b1111111110000000 %
b1111111110000000 )
b1111111110000000 M
b1111111110000000 Y
b1111111110000000 e
b100 '
#500
15
b1000000000000000 &
b1000000000000000 *
b1000000000000000 S
b1000000000000000 _
b1000000000000000 k
b101 '
#600
1-
b11111111 4
b0 "
b0 H
b0 3
b111111110000000 !
b111111110000000 1
02
0,
0+
b11111011 E
b1111100 B
0<
05
b11111100 D
b11111011 G
b101111010 F
b1111011 7
b111111000000000 C
b1111100 6
b1111011 U
b1111100 T
b1111011 a
b1111100 `
b1111011 m
b1111100 l
08
b11110111111100 &
b11110111111100 *
b11110111111100 S
b11110111111100 _
b11110111111100 k
b111111110000000 %
b111111110000000 )
b111111110000000 M
b111111110000000 Y
b111111110000000 e
b110 '
#700
b1111111110000000 !
b1111111110000000 1
12
15
b1011110111111100 &
b1011110111111100 *
b1011110111111100 S
b1011110111111100 _
b1011110111111100 k
b111 '
#800
05
18
b11110111111100 &
b11110111111100 *
b11110111111100 S
b11110111111100 _
b11110111111100 k
b1111111110000000 %
b1111111110000000 )
b1111111110000000 M
b1111111110000000 Y
b1111111110000000 e
b1000 '
#900
b111111110000000 !
b111111110000000 1
02
15
b1011110111111100 &
b1011110111111100 *
b1011110111111100 S
b1011110111111100 _
b1011110111111100 k
b1001 '
#1000
b1010 '
