$date
	Sat Jun 01 15:21:52 2024
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module iv_fp_mul_tb $end
$var wire 16 ! out [15:0] $end
$var wire 2 " error [1:0] $end
$var parameter 32 # DATA_WIDTH $end
$var parameter 32 $ ERROR_WIDTH $end
$var reg 16 % in1 [15:0] $end
$var reg 16 & in2 [15:0] $end
$var integer 32 ' i [31:0] $end
$scope module uut $end
$var wire 16 ( in1 [15:0] $end
$var wire 16 ) in2 [15:0] $end
$var wire 1 * mult_by_zero $end
$var wire 1 + op3_sign $end
$var wire 1 , overflow $end
$var wire 1 - underflow $end
$var wire 16 . out [15:0] $end
$var wire 7 / op3_frac [6:0] $end
$var wire 8 0 op3_exp [7:0] $end
$var wire 1 1 op2_sign $end
$var wire 7 2 op2_frac [6:0] $end
$var wire 8 3 op2_exp [7:0] $end
$var wire 1 4 op1_sign $end
$var wire 7 5 op1_frac [6:0] $end
$var wire 8 6 op1_exp [7:0] $end
$var wire 1 7 normalise $end
$var wire 7 8 frac_prod_norm [6:0] $end
$var wire 16 9 frac_prod [15:0] $end
$var wire 9 : exp_sum_plus_1 [8:0] $end
$var wire 8 ; exp_sum_norm [7:0] $end
$var wire 9 < exp_sum_exp1_plus_exp2 [8:0] $end
$var wire 9 = exp_sum [8:0] $end
$var wire 2 > error [1:0] $end
$var parameter 32 ? DATA_WIDTH $end
$var parameter 32 @ ERROR_WIDTH $end
$var parameter 32 A EXP_WIDTH $end
$var parameter 32 B FRAC_WIDTH $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b111 B
b1000 A
b10 @
b10000 ?
b10 $
b10000 #
$end
#0
$dumpvars
b10 >
b110000001 =
b0 <
b10000001 ;
b110000010 :
b100000100000001 9
b10 8
07
b0 6
b1 5
04
b0 3
b1 2
01
b10000001 0
b10 /
b100000010000010 .
1-
0,
0+
0*
b1 )
b1 (
b0 '
b1 &
b1 %
b10 "
b100000010000010 !
$end
#100
b11111111 0
b1 "
b1 >
b111111111111110 !
b111111111111110 .
b1111110 /
1,
0-
b10000000 ;
b1111110 8
17
b11111111 3
b1111111 2
b110000000 :
b101111111 =
b111111110 <
b11111111 6
b1111111000000001 9
b1111111 5
b111111111111111 &
b111111111111111 )
b111111111111111 %
b111111111111111 (
b1 '
#200
b10000001 0
b0 "
b0 >
0,
b100000010000010 !
b100000010000010 .
b10 /
b10000001 ;
b10 8
07
b10000000 3
b1 2
b10000010 :
b10000001 =
b100000000 <
b10000000 6
b100000100000001 9
b1 5
b100000000000001 &
b100000000000001 )
b100000000000001 %
b100000000000001 (
b10 '
#300
b10 "
b10 >
b111111110000010 !
b111111110000010 .
b11111111 0
1-
b11111111 ;
b111111 3
b0 :
b111111111 =
b1111110 <
b111111 6
b1111110000001 &
b1111110000001 )
b1111110000001 %
b1111110000001 (
b11 '
#400
b0 "
b0 >
b110000010 !
b110000010 .
b11 0
0-
b11 ;
b1000001 3
b100 :
b11 =
b10000010 <
b1000001 6
b10000010000001 &
b10000010000001 )
b10000010000001 %
b10000010000001 (
b100 '
#500
b1111010 0
b11110101111000 !
b11110101111000 .
b1111000 /
b1111010 ;
b1111000 8
b1111101 3
b1110011 2
b1111011 :
b1111010 =
b11111001 <
b1111100 6
b111110001011001 9
b11 5
b11111011110011 &
b11111011110011 )
b11111000000011 %
b11111000000011 (
b101 '
#600
b1111110 0
b11111100011010 !
b11111100011010 .
b11010 /
b1111110 ;
b11010 8
17
b1111110 3
b101100 2
b1111110 :
b1111101 =
b11111100 <
b1111110 6
b1001101010001000 9
b1100110 5
b11111100101100 &
b11111100101100 )
b11111101100110 %
b11111101100110 (
b110 '
#700
b1111101 0
b11111011011010 !
b11111011011010 .
b1011010 /
b1111101 ;
b1011010 8
07
b11001 2
b110110101011111 9
b110111 5
b11111100011001 &
b11111100011001 )
b11111100110111 %
b11111100110111 (
b111 '
#800
b1110100 0
b11101000001011 !
b11101000001011 .
b1011 /
b1110100 ;
b1011 8
17
b1110101 3
b10000 2
b1110100 :
b1110011 =
b11110010 <
b1111101 6
b1000101110000000 9
b1111000 5
b11101010010000 &
b11101010010000 )
b11111011111000 %
b11111011111000 (
b1000 '
#900
b1111101 0
b11111011011101 !
b11111011011101 .
b1011101 /
b1111101 ;
b1011101 8
07
b1111110 3
b100000 2
b1111110 :
b1111101 =
b11111100 <
b1111110 6
b110111010100000 9
b110001 5
b11111100100000 &
b11111100100000 )
b11111100110001 %
b11111100110001 (
b1001 '
#1000
b1010 '
